var path = require("path");
var CppComponent = require("../../components/types/c++");


/**
 * Removes unsupported symbols from names.
 * Symbols are converted to _.
 * 
 * Currently the following symbols are replaced:
 *   - ~ ; #
 * 
 * @param {!String} name The name to clean.
 * @returns {!String} the clean name.
 */
var clean_name = function clean_name(name) {
  name = name.replace(/-/g, "_");
  name = name.replace(/~/g, "_");
  name = name.replace(/;/g, "_");
  name = name.replace(/#/g, "_");
  return name;
};


module.exports = function(grunt) {
  var generator = function generator(target) {
    if (!target) {
      throw new Error(
          "generate-modules-link task needs a target to process. " +
          "Try generate-modules-link:release"
      );
    }

    grunt.config.requires("get-components");
    var components = grunt.config.get("get-components")(target);

    if (!components.has("daemon")) {
      grunt.log.ok("Skipping modules link as daemon was not found!");
      return;
    }

    var daemon = components.get("daemon");
    if (!(daemon instanceof CppComponent)) {
      throw new Error("Daemon module must be a C++ module");
    }

    // Get path and build generated module path.
    var source_path = path.join(
        daemon.getPath(), "src", "plugins", "initialise_extensions.cpp"
    );

    // Generate the module.
    var content = module.exports.HEADER;
    var lines = [];
    var deps  = components.resolve("daemon", target);

    // Exclude daemon itself.
    deps.pop();
    deps.forEach(function(dep) {
      var instance = dep.instance;
      if (!instance.hasModuleInit()) {
        return;
      }

      var template = module.exports.LINE_TEMPLATE;
      var name = clean_name(instance.name());
      lines.push(template.replace("{name}", name));
    });
    
    // Finish file.
    content += lines.join('\n');
    content += module.exports.FOOTER;

    // Compare with existing version and avoid updates if possible.
    if (grunt.file.exists(source_path)) {
      var current = grunt.file.read(source_path);
      if (content === current) {
        grunt.log.writeln("Skipped update of extension initalisation file.");
        return;
      }
    }

    // Write it to disk.
    grunt.file.write(source_path, content);
  };

  grunt.registerTask(
      "generate-modules-link",
      "Generates the C++ source file to link modules into the daemon",
      generator
  );
};


// Footer to append to generated module.
// (one new line requires two empty strings).
module.exports.FOOTER = [
  "", ""
].join('\n');

// Header to prepend to generated module.
module.exports.HEADER = [
  "// Copyright 2015 Stefano Pogliani <stafano@spogliani.net>",
  "// This file is automatically generated by the generate-modules-link task.",
  "// **Any changes** made to this file will be lost!!!",
  "",
  "// To add new modules and have the initialised in this file ensure",
  "// that an appropriate module-type is set in the component.json",
  "// file you want injected.",
  "",
  "#include <injector/extension.h>",
  "", "", ""
].join('\n');

// Template for lines to generate in the file.
module.exports.LINE_TEMPLATE = "INITIALISE_EXTENSION({name});";
